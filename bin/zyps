#!/usr/local/bin/ruby

# Copyright 2007 Jay McGavren, jay@mcgavren.com.
# 
# This file is part of Zyps.
# 
# Zyps is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


gems_loaded = false
begin
	require 'optparse'
	require 'zyps'
	require 'zyps/actions'
	require 'zyps/conditions'
	require 'zyps/environmental_factors'
	require 'zyps/remote'
	require 'zyps/views/trails'
rescue LoadError
	if gems_loaded == false
		require 'rubygems'
		gems_loaded = true
		retry
	else
		raise
	end
end


include Zyps


DEFAULT_VIEW_WIDTH = 800
DEFAULT_VIEW_HEIGHT = 600
DEFAULT_MAX_SPEED = 200
DEFAULT_MAX_POPULATION = 100
DEFAULT_FPS = 60


class Application

	#Port to open service on.
	attr_accessor :uri
	#Maximum allowed number of objects.
	attr_accessor :max_population
	#View dimensions.
	attr_accessor :view_width, :view_height
	
	#Create app window, game environment, and view.
	#Set up default values.
	#Takes a hash with these keys and defaults:
	#	:uri => nil,
	#	:view_width => DEFAULT_VIEW_WIDTH,
	#	:view_height => DEFAULT_VIEW_HEIGHT,
	#	:fps => DEFAULT_FPS,
	#	:max_population => DEFAULT_MAX_POPULATION,
	#	:max_speed => DEFAULT_MAX_SPEED,
	#	:enclosure => true
	def initialize(options = {})
		
		options = {
			:uri => nil,
			:view_width => DEFAULT_VIEW_WIDTH,
			:view_height => DEFAULT_VIEW_HEIGHT,
			:fps => DEFAULT_FPS,
			:max_population => DEFAULT_MAX_POPULATION,
			:max_speed => DEFAULT_MAX_SPEED,
			:enclosure => true
		}.merge(options)
		
		@uri, @view_width, @view_height, @fps, @max_population, @max_speed, @enclosure =
		options[:uri], options[:view_width], options[:view_height], options[:fps], options[:max_population], options[:max_speed], options[:enclosure]
		
	end
	
	
	def main
	
		#Create a window, and set GTK up to quit when it is closed.
		window = Gtk::Window.new
		window.resizable = false
		window.signal_connect("delete_event") {false}
		window.signal_connect("destroy") {Gtk.main_quit}
		
		#Create environment.
		@environment = Environment.new
		
		#Set up controls.
		#Also initializes @view.
		window.add(create_controls({:view_width => @view_width, :view_height => @view_height}))
	
		#Show all widgets.
		window.show_all
			
		#Point view at environment.
		@environment.add_observer(@view)
		
		#Keep objects on screen.
		if @enclosure
			enclosure = Enclosure.new(
				:left => 0,
				:bottom => 0,
				:top => @view_height,
				:right => @view_width
			)
			@environment.environmental_factors << enclosure
		end
		
		#Keep all objects under a certain speed.
		@environment.environmental_factors << SpeedLimit.new(@max_speed) if @max_speed
		
		#Limit population.
		@environment.environmental_factors << PopulationLimit.new(@max_population) if @max_population
		
		#Set up a creature generator.
		@generator = CreatureGenerator.new(@environment)

		#Create thread to update environment.
		thread = Thread.new do
		
			begin
			
				drawing_clock = Clock.new
				time_per_frame = 1.0 / @fps
				
				loop do

					@environment.interact
					
					#Determine how much time is left in this frame.
					time_left_in_frame = (time_per_frame) - drawing_clock.elapsed_time
					#Sleep for the remaining time.
					if time_left_in_frame > 0
						sleep time_left_in_frame
					#Skip a frame if things are going too slow.
					else
						sleep time_per_frame
					end
					
				end
				
			rescue Exception => exception
				puts exception, exception.backtrace
			end
			
		end
		
		
		#Start a network service.
		if @uri
			server = EnvironmentServer.new(@environment, @uri)
			server.start
			#Disable file system access.
			$SAFE = 2
		end

		
		#Activate the GUI.
		Gtk.main
		
	end
	
	
	#Create a view and controls.
	#Takes a hash with these defaults:
	#	:view_width => @view_width
	#	:view_height => @view_height
	#	:homogeneous => false
	#	:spacing => 0
	#	:expand => false
	#	:fill => false
	#	:padding => 0
	def create_controls(options = {})
	
		options = {
			:view_width => @view_width,
			:view_height => @view_height,
			:homogeneous => false,
			:spacing => 0,
			:expand => false,
			:fill => false,
			:padding => 0,
		}.merge(options)
		
		#Create a container for the view and controls.
		interface = Gtk::HBox.new(options[:homogeneous], options[:spacing])
		
		#Add view to interface.
		@view = TrailsView.new(
			:width => options[:view_width],
			:height => options[:view_height],
			:trail_length => 5
		)
		interface.pack_start(@view.canvas, options[:expand], options[:fill], options[:padding])
		
		#When mouse button pressed, record location for use in release event handler.
		@view.canvas.add_events(Gdk::Event::BUTTON_PRESS_MASK)
		@view.canvas.signal_connect("button-press-event") do |canvas, event|
			@press_location = Location.new(event.x, event.y)
		end
		
		#Create a creature on button release.
		@view.canvas.add_events(Gdk::Event::BUTTON_RELEASE_MASK)
		@view.canvas.signal_connect("button-release-event") do |canvas, event|
			#Ensure the mouse was pressed within the canvas.
			if @press_location
				#Create creature at release location.
				@release_location = Location.new(event.x, event.y)
				@generator.create_creature(
					:x => event.x,
					:y => event.y,
					:speed => Utility.find_distance(@press_location, @release_location) * 2, #Use distance dragged as speed.
					:pitch => Utility.find_angle(@press_location, @release_location), #Move in direction of drag.
					:turn => @turn_flag.active?,
					:approach => @approach_flag.active?,
					:flee => @flee_flag.active?,
					:push => @push_flag.active?,
					:pull => @pull_flag.active?,
					:breed => @breed_flag.active?,
					:eat => @eat_flag.active?
				)
				#Nullify press location, as it is no longer applicable.
				@press_location = nil
			end
		end
		
		#Create a VBox for all controls.
		control_panel = Gtk::VBox.new(options[:homogeneous], options[:spacing])
		
		#Create a group for the actions.
		action_controls = Gtk::VBox.new(options[:homogeneous], options[:spacing])
		action_controls.pack_start(Gtk::Label.new("Actions"), options[:expand], options[:fill], options[:padding])
		@turn_flag = Gtk::CheckButton.new("Turn")
		action_controls.pack_start(@turn_flag, options[:expand], options[:fill], options[:padding])
		@approach_flag = Gtk::CheckButton.new("Chase")
		action_controls.pack_start(@approach_flag, options[:expand], options[:fill], options[:padding])
		@flee_flag = Gtk::CheckButton.new("Flee")
		action_controls.pack_start(@flee_flag, options[:expand], options[:fill], options[:padding])
		@push_flag = Gtk::CheckButton.new("Push")
		action_controls.pack_start(@push_flag, options[:expand], options[:fill], options[:padding])
		@pull_flag = Gtk::CheckButton.new("Pull")
		action_controls.pack_start(@pull_flag, options[:expand], options[:fill], options[:padding])
		@breed_flag = Gtk::CheckButton.new("Breed")
		action_controls.pack_start(@breed_flag, options[:expand], options[:fill], options[:padding])
		@eat_flag = Gtk::CheckButton.new("Eat")
		action_controls.pack_start(@eat_flag, options[:expand], options[:fill], options[:padding])
		#Add the action controls to the panel.
		control_panel.pack_start(action_controls, options[:expand], options[:fill], options[:padding])
		
		#Create a group for environment controls.
		environment_controls = Gtk::VBox.new(options[:homogeneous], options[:spacing])
		environment_controls.pack_start(Gtk::Label.new("Environment"), options[:expand], options[:fill], options[:padding])
		@clear_button = Gtk::Button.new("Clear")
		@clear_button.signal_connect("clicked") {
			@environment.objects = []
		}
		environment_controls.pack_start(@clear_button, options[:expand], options[:fill], options[:padding])
		#Add the environment controls to the panel.
		control_panel.pack_start(environment_controls, options[:expand], options[:fill], options[:padding])
		
		#Add the control panel to the interface.
		interface.pack_start(control_panel, options[:expand], options[:fill], options[:padding])
		
		interface
		
	end


	#Set attributes according to command-line arguments.
	def process_options(arguments)
	
		#Set up option parser.
		options = OptionParser.new
		
		#Define valid options.
		options.on("-h", "--help", TrueClass, "Display program help.") {
			puts options.help
			exit
		}
		options.on(
			"-m",
			"--max-population [number]",
			Integer,
			"The maximum number of allowed game objects.  #{DEFAULT_MAX_POPULATION} by default."
		) {|value| @max_population = value}
		options.on(
			"-s",
			"--max-speed [number]",
			Integer,
			"The fastest an object can go.  #{DEFAULT_MAX_SPEED ? DEFAULT_MAX_SPEED : 'No limit'} by default."
		) {|value| @max_speed = value}
		options.on(
			"-n",
			"--no-enclosure",
			"Disables the barrier that normally keeps objects on the screen."
		) {|value| @enclosure = false}
		options.on(
			"-u",
			"--uri [uri]",
			String,
			"URI to serve the environment on via dRuby.  If not specified, no server will be started."
		) {|value| @uri = value}
		options.on(
			"-f",
			"--fps [frames]",
			Integer,
			"Number of frames to draw per second.  #{DEFAULT_FPS} by default."
		) {|value| @fps = value}
		options.on(
			"--view-width [pixels]",
			Integer,
			"Window width.  #{DEFAULT_VIEW_WIDTH} by default."
		) {|value| @view_width = value}
		options.on(
			"--view-height [pixels]",
			Integer,
			"Window height.  #{DEFAULT_VIEW_HEIGHT} by default."
		) {|value| @view_height = value}
		
		#Parse the options, printing usage if parsing fails.
		options.parse(arguments) rescue puts "#{$!}\nType '#{$0} --help' for valid options."
		
	end


end



class CreatureGenerator
	
	#Environment creatures will be added to.
	attr_accessor :environment
	#Default required proximity for actions.
	attr_accessor :default_proximity
	#Rate of new TurnActions.
	attr_accessor :turn_rate
	#Acceleration rate of new ApproachActions.
	attr_accessor :approach_rate
	#Acceleration rate of new FleeActions.
	attr_accessor :flee_rate
	#Strength of new PullActions.
	attr_accessor :pull_strength
	#Strength of new PushActions.
	attr_accessor :push_strength
	
	def initialize(environment)
	
		@environment = environment
		
		#Set up defaults for attributes.
		@default_proximity = 200
		@approach_rate = 200
		@flee_rate = @approach_rate
		@push_strength = @approach_rate * 2
		@pull_strength = @push_strength * 0.75
		@turn_rate = @approach_rate * 1.1
		@turn_angle = 90
		@breed_rate = 10
		
	end


	#Create a creature and add it to the environment.
	def create_creature(options = {})
	
		options = {
			:x => 0,
			:y => 0,
			:speed => 1,
			:pitch => 0,
			:action_proximity => @default_proximity,
			:turn => false,
			:approach => false,
			:flee => false,
			:push => false,
			:pull => false,
			:breed => false,
			:eat => false,
		}.merge(options)
		
		#Create a creature.
		creature = Creature.new(
			:location => Location.new(options[:x], options[:y]),
			:vector => Vector.new(options[:speed], options[:pitch]),
			:size => 5
		)
		
		#Set up actions and merge colors according to selected behaviors.
		color = Color.new(0.5, 0.5, 0.5)
		if options[:turn]
			color.blue += 1
			creature.behaviors << Behavior.new(
				:actions => [TurnAction.new(@turn_rate, @turn_angle)],
				:conditions => [ProximityCondition.new(options[:action_proximity] * 2)]
			)
		end
		if options[:approach]
			color.red += 1
			creature.behaviors << create_behavior(
				:actions => [ApproachAction.new(@approach_rate)],
				:conditions => [ProximityCondition.new(options[:action_proximity])]
			)
		end
		if options[:flee]
			color.red += 0.5; color.green += 0.5 #Yellow.
			creature.behaviors << create_behavior(
				:actions => [FleeAction.new(@flee_rate)],
				:conditions => [ProximityCondition.new(options[:action_proximity] * 0.5)]
			)
		end
		if options[:push]
			color.red += 0.5; color.blue += 0.5 #Purple.
			creature.behaviors << create_behavior(
				:actions => [PushAction.new(@push_strength)],
				:conditions => [ProximityCondition.new(options[:action_proximity] * 0.25)]
			)
		end
		if options[:pull]
			color.blue += 0.75; color.green += 0.75 #Aqua.
			creature.behaviors << create_behavior(
				:actions => [PullAction.new(@pull_strength)],
				:conditions => [ProximityCondition.new(options[:action_proximity] * 0.75)]
			)
		end
		if options[:breed]
			color.green -= 0.1 #Make a bit redder.
			color.blue -= 0.1
			creature.behaviors << create_behavior(
				:actions => [BreedAction.new(@environment, @breed_rate)],
				:conditions => [CollisionCondition.new] #The default ProximityCondition won't do.
			)
		end
		if options[:eat]
			color.green += 1
			creature.behaviors << create_behavior(
				:actions => [EatAction.new(@environment)],
				:conditions => [
					CollisionCondition.new, #The default ProximityCondition won't do.
					StrengthCondition.new #The eater should be as strong or stronger than its dinner.
				] 
			)
		end
		
		creature.color = color
		
		@environment.objects << creature
		
	end
	
	
	def create_behavior(options = {})
	
		options = {
			:actions => [],
			:conditions => [ProximityCondition.new(@default_proximity)],
		}.merge(options)
		
		behavior = Behavior.new
		behavior.actions = options[:actions]
		behavior.conditions = options[:conditions]
		behavior
		
	end
	
	
end



begin
	#Create a server.
	application = Application.new
	#Parse the command line.
	application.process_options(ARGV)
	#Start the server.
	application.main
rescue => exception
	#Print error to STDERR and exit with an abnormal status.
	abort "Error: " + exception.message + exception.backtrace.join("\n")
end
