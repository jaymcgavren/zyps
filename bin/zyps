#!/usr/local/bin/ruby

# Copyright 2007 Jay McGavren, jay@mcgavren.com.
# 
# This file is part of Zyps.
# 
# Zyps is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


begin
	require 'zyps'
	require 'zyps/views/trails'
rescue LoadError
	require 'rubygems'
	require 'zyps'
	require 'zyps/views/trails'
end


#Generates new creatures and places them in an environment.
class Generator

	#Environment creatures will be spawned into.
	attr_accessor :environment
	#Boundary that all new objects must be inside.
	attr_accessor :min_x, :min_y, :max_x, :max_y
	#Array of tags to choose from when generating new one.
	attr_accessor :tag_pool
	#Array of colors to choose from when generating new one.
	attr_accessor :color_pool
	#The maximum speed a new creature should be going.
	attr_accessor :max_speed
	#The maximum number of behaviors a creature can have.
	attr_accessor :max_behaviors
	#The maximum number of conditions a Behavior can have.
	attr_accessor :max_conditions
	#The maximum number of actions a Behavior can have.
	attr_accessor :max_actions
	
	def initialize(environment, min_x, min_y, max_x, max_y)
		@environment, @min_x, @min_y, @max_x, @max_y = environment, min_x, min_y, max_x, max_y
		@tag_pool = %q{foo bar baz}
		@color_pool = []
		@max_behaviors = 2
		@max_conditions = 2
		@max_actions = 2
		@max_speed = 100
	end
	
	#Create a creature.
	def create_creature()
	
		creature = Creature.new()
		#Create a Color.
		creature.color = create_color
		#Create a Location.
		creature.location = create_location
		#Create a Vector.
		creature.vector = create_vector()
		#Create a random tag.
		creature.tags << create_tag()
		#Create a random number of behaviors.
		generate_number(0, @max_behaviors).to_i.times {creature.behaviors << create_behavior()}
		
		creature
		
	end
	
	#Create a random tag.
	#Chooses from tag_pool.
	def create_tag()
		@tag_pool[generate_number(0, @tag_pool.length).to_i]
	end
	#Create a random Color.
	#Chooses from color_pool, or creates a random one from scratch if color_pool is empty.
	def create_color()
		if (color_pool.length != 0) then
			return @color_pool[generate_number(0, @color_pool.length).to_i]
		else
			return Color.new(generate_random_number(0, 1), generate_random_number(0, 1), generate_random_number(0, 1))
		end
	end
	#Create a random Location.
	def create_location()
		Location.new(
			generate_random_number(0, @max_x - @min_x) + @min_x,
			generate_random_number(0, @max_y - @min_y) + @min_y
		)
	end
	#Create a random Vector.
	def create_vector()
		Vector.new(generate_number(0, @max_speed), generate_number(0, 360))
	end
	#Create a random Behavior.
	def create_behavior()
		behavior = Behavior.new
		action_count = generate_number(0, @max_actions).to_i
		action_count.times do
			behavior.actions << create_action()
		end
		#Only add conditions if there's an action.
		if action_count > 0 then
			#There should always be a proximity condition.
			behavior.conditions << create_proximity_condition()
			#Add some additional conditions.
			generate_random_number(0, @max_conditions).to_i.times do
				behavior.conditions << create_condition()
			end
		end
		behavior
	end
	#Create a random condition.
	def create_condition()
		case generate_number(0, 2).to_i
		when 0
			return create_tag_condition()
		when 1
			return create_age_condition()
		else
			raise "Invalid condition"
		end
	end
	#Create a condition that looks for a random tag.
	def create_tag_condition()
		tag = create_tag()
		lambda {|creature, target| target.tags.include?(tag)}
	end
	#Create a condition that looks for a random age.
	def create_age_condition()
		age = generate_number(0, 60)
		lambda {|creature, target| target.age > age}
	end
	#Create a condition that looks for a random proximity.
	def create_proximity_condition()
		proximity = generate_number(0, 100)
		lambda do |creature, target|
			Utility.find_distance(creature.location, target.location) < proximity
		end
	end
	#Create a random action.
	def create_action()
		case generate_random_number(0, 9).to_i
		when 0
			return create_accelerate_action()
		when 1
			return create_approach_action()
		when 2
			return create_flee_action()
		when 3
			return create_blend_action()
		when 4
			return create_mate_action()
		when 5
			return create_spawn_action()
		when 6
			return create_turn_action()
		when 7
			return create_eat_action()
		when 8
			return create_tag_action()
		else
			raise "Invalid action"
		end
	end
	#Create an action that accelerates at a random rate.
	def create_accelerate_action()
		clock = Clock.new()
		rate = generate_number(0, 10)
		lambda {|creature, target| creature.vector.speed += rate * clock.elapsed_time}
	end
	#Create an action that turns in a circle.
	def create_turn_action()
		clock = Clock.new()
		rate = generate_number(0, 360)
		lambda {|creature, target| creature.vector.pitch += rate * clock.elapsed_time}
	end
	#Create an action that approaches the target.
	def create_approach_action()
		heading = Vector.new
		rate = generate_number(0, 20)
		lambda do |creature, target|
			#Find the difference between the current heading and the angle to the target.
			turn_angle = Utility.find_angle(creature.location, target.location) - heading.pitch
			#If the angle is the long way around from the current heading, change it to the smaller angle.
			if turn_angle > 180 then
				turn_angle -= 360.0
			elsif turn_angle < -180 then
				turn_angle += 360.0
			end
			#If turn angle is greater than allowed turn speed, reduce it.
			turn_angle = Utility.constrain_value(turn_angle, rate)
			#Turn the appropriate amount.
			heading.pitch += turn_angle
			#Apply the heading to the creature's movement vector.
			creature.vector += heading
		end
	end
	#Create an action that flees from the target.
	def create_flee_action()
		heading = Vector.new
		rate = generate_number(0, 20)
		lambda do |creature, target|
			#Find the difference between the current heading and the angle AWAY from the target.
			turn_angle = Utility.find_angle(creature.location, target.location) - heading.pitch + 180
			#If the angle is the long way around from the current heading, change it to the smaller angle.
			if turn_angle > 180 then
				turn_angle -= 360.0
			elsif turn_angle < -180 then
				turn_angle += 360.0
			end
			#If turn angle is greater than allowed turn speed, reduce it.
			turn_angle = Utility.constrain_value(turn_angle, rate)
			#Turn the appropriate amount.
			heading.pitch += turn_angle
			#Apply the heading to the creature's movement vector.
			creature.vector += heading
		end
	end
	#Create an action that shifts the subject's color to match the target.
	def create_blend_action()
		lambda {|creature, target| creature.color += target.color}
	end
	#Create an action that mates with the target.
	def create_mate_action()
		#TODO
		lambda {|creature, target| }
	end
	#Create an action that spawns a new creature.
	def create_spawn_action()
		#TODO
		lambda {|creature, target| }
	end
	#Create an action that eats the target.
	def create_eat_action()
		lambda {|creature, target| @environment.objects.delete(target)}
	end
	#Create an action that applies a tag to the target.
	def create_tag_action()
		tag = create_tag()
		lambda {|creature, target| target.tags << tag unless target.tags.include?(tag)}
	end
	#Generate a number between the given minimum and maximum, based on the current system time.
	def generate_number(minimum, maximum)
		(Time.new.to_f % (maximum - minimum)) + minimum
	end
	#Generate a random number between the given minimum and maximum.
	def generate_random_number(minimum, maximum)
		value = rand * (maximum - minimum) + minimum
	end
end



#Keeps all objects within a set of walls.
class EncloseBehavior < Behavior

	#Positions of walls.
	attr_accessor :left, :top, :right, :bottom
	
	def initialize
		super
		@left, @top, @right, @bottom = 0, 0, 0, 0
		@actions << lambda do |boundary, object|
			#If object is beyond a boundary, set its position equal to the boundary and reflect it.
			if (object.location.x < @left) then
				object.location.x = @left
				object.vector.pitch = Utility.find_reflection_angle(90, object.vector.pitch)
			elsif (object.location.x > @right) then
				object.location.x = @right
				object.vector.pitch = Utility.find_reflection_angle(270, object.vector.pitch)
			end
			if (object.location.y < @top) then
				object.location.y = @top
				object.vector.pitch = Utility.find_reflection_angle(0, object.vector.pitch)
			elsif (object.location.y > @bottom) then
				object.location.y = @bottom
				object.vector.pitch = Utility.find_reflection_angle(180, object.vector.pitch)
			end
		end
	end
	
end



class Application

	#Tags to randomly choose from.
	attr_accessor :tag_pool
	#Colors to randomly choose from.
	attr_accessor :color_pool
	#Seconds between creature creation.
	attr_accessor :birth_rate
	
	#Create app window, game environment, and view.
	def initialize(width, height)
		
		@width, @height = width, height
		@birth_rate = 1
		@fps = 30.0
		
		#Create a window, and set GTK up to quit when it is closed.
		window = Gtk::Window.new
		window.signal_connect("delete_event") {false}
		window.signal_connect("destroy") {Gtk.main_quit}
		
		#Set up controls.
		window.add(create_controls)
	
		#Show all widgets.
		window.show_all
		
		#Create environment.
		@environment = Environment.new
		
		#Point view at environment.
		@environment.add_observer(@view)
		
	end
	
	
	def main
	
	
		#Keep all objects within a boundary.
		enclose = EncloseBehavior.new()
		enclose.left = 0
		enclose.right = @width
		enclose.top = 0
		enclose.bottom = @height
		@environment.environmental_factors << EnvironmentalFactor.new([enclose])

		#Create a creature generator.
		generator = Generator.new(@environment, 0, 0, @width, @height)

		#Create thread to update environment.
		thread = Thread.new do
		
			begin
			
				drawing_clock = Clock.new
				birth_clock = Clock.new
				time_per_frame = 1.0 / @fps
				time_since_birth = 0
				
				loop do
				
					@environment.interact
					
					#Control population.
					@environment.objects.shift while @environment.objects.length > 25
					#Create new creature every few seconds.
					if (time_since_birth += birth_clock.elapsed_time) > birth_rate
						creature = Creature.new(
							'',
							generator.create_location,
							Color.new(@red_slider.value, @green_slider.value, @blue_slider.value),
							generator.create_vector,
							0,
							@tags_box.text.split(/,\s*/)
						)
						behavior = Behavior.new
						condition_tags = @tag_condition_box.text
						condition_tags.split(/,\s*/).each do |tag|
							behavior.conditions << lambda do |creature, target|
								target.tags.include?(tag)
							end
						end
						proximity = @proximity_condition_slider.value
						if proximity > 0
							behavior.conditions << lambda do |creature, target|
								Utility.find_distance(creature.location, target.location) < proximity
							end
						end
						age = @age_condition_slider.value
						if age > 0
							behavior.conditions << lambda do |creature, target|
								target.age > age
							end
						end
						acceleration = @acceleration_slider.value
						if acceleration != 0
							behavior.actions << lambda do |creature, target|
								creature.vector.speed += acceleration
								creature.vector.speed = 0 if creature.vector.speed < 0
							end
						end
						turn = @turn_slider.value
						if turn != 0
							behavior.actions << lambda do |creature, target|
								creature.vector.pitch += turn
							end
						end
						approach_angle = @approach_slider.value
						if approach_angle > 0
							heading = creature.vector.clone
							behavior.actions << lambda do |creature, target|
								#Find the difference between the current heading and the angle to the target.
								turn_angle = Utility.find_angle(creature.location, target.location) - heading.pitch
								#If the angle is the long way around from the current heading, change it to the smaller angle.
								if turn_angle > 180 then
									turn_angle -= 360.0
								elsif turn_angle < -180 then
									turn_angle += 360.0
								end
								#If turn angle is greater than allowed turn speed, reduce it.
								turn_angle = Utility.constrain_value(turn_angle, approach_angle)
								#Turn the appropriate amount.
								heading.pitch += turn_angle
								#Apply the heading to the creature's movement vector.
								creature.vector += heading
							end
						end
						flee_angle = @flee_slider.value
						if flee_angle > 0
							heading = creature.vector.clone
							behavior.actions << lambda do |creature, target|
								#Find the difference between the current heading and the angle to the target.
								turn_angle = Utility.find_angle(creature.location, target.location) - heading.pitch + 180
								#If the angle is the long way around from the current heading, change it to the smaller angle.
								if turn_angle > 180 then
									turn_angle -= 360.0
								elsif turn_angle < -180 then
									turn_angle += 360.0
								end
								#If turn angle is greater than allowed turn speed, reduce it.
								turn_angle = Utility.constrain_value(turn_angle, flee_angle)
								#Turn the appropriate amount.
								heading.pitch += turn_angle
								#Apply the heading to the creature's movement vector.
								creature.vector += heading
							end
						end
						if @eat_flag.active?
							behavior.actions << lambda do |creature, target|
								@environment.objects.delete(target)
							end
						end
						apply_tags = @tag_action_box.text
						apply_tags.split(/,\s*/).each do |tag|
							behavior.conditions << lambda do |creature, target|
								target.tags << tag unless target.tags.include?(tag)
							end
						end
						creature.behaviors << behavior
						@environment.objects << creature
						time_since_birth = 0
					end
					
					#Determine how much time is left in this frame.
					time_left_in_frame = (time_per_frame) - drawing_clock.elapsed_time
					#Sleep for the remaining time.
					if time_left_in_frame > 0
						sleep time_left_in_frame
					#Skip a frame if things are going too slow.
					else
						sleep time_per_frame
					end
					
				end
				
			rescue Exception => exception
				puts exception, exception.backtrace
			end
			
		end
		
		#Activate the GUI.
		Gtk.main
		
	end
	
	
	#Create a view and controls.
	def create_controls(width = @width, height = @height, homogeneous = false, spacing = 0, expand = false, fill = false, padding = 0)
	
		#Create a container for the view and controls.
		interface = Gtk::HBox.new(homogeneous, spacing)
		
		#Add view to interface.
		@view = TrailsView.new(width, height)
		interface.pack_start(@view.canvas, expand, fill, padding)
		
		#Create a VBox for all controls.
		control_panel = Gtk::VBox.new(homogeneous, spacing)
	
		#Create a group for the new object's attributes.
		attribute_controls = Gtk::VBox.new(homogeneous, spacing)
		
		#Add sliders for the color components.
		attribute_controls.pack_start(Gtk::Label.new("Color"), expand, fill, padding)
		attribute_controls.pack_start(Gtk::Label.new("R"), expand, fill, padding)
		@red_slider = Gtk::HScale.new(0, 1, 0.1)
		attribute_controls.pack_start(@red_slider, expand, fill, padding)
		attribute_controls.pack_start(Gtk::Label.new("G"), expand, fill, padding)
		@green_slider = Gtk::HScale.new(0, 1, 0.1)
		attribute_controls.pack_start(@green_slider, expand, fill, padding)
		attribute_controls.pack_start(Gtk::Label.new("B"), expand, fill, padding)
		@blue_slider = Gtk::HScale.new(0, 1, 0.1)
		attribute_controls.pack_start(@blue_slider, expand, fill, padding)
		@red_slider.value, @green_slider.value, @blue_slider.value = 1, 1, 1
				
		#Add a text box for the tags.
		attribute_controls.pack_start(Gtk::Label.new("Tags"), expand, fill, padding)
		@tags_box = Gtk::Entry.new
		attribute_controls.pack_start(@tags_box, expand, fill, padding)
		
		#Add the attribute controls to the panel.
		control_panel.pack_start(attribute_controls, expand, fill, padding)
		
		#Create a group for the conditions.
		condition_controls = Gtk::VBox.new(homogeneous, spacing)
		condition_controls.pack_start(Gtk::Label.new("Target"), expand, fill, padding)
		#Add a text box for the tag condition.
		condition_controls.pack_start(Gtk::Label.new("Tags"), expand, fill, padding)
		@tag_condition_box = Gtk::Entry.new
		condition_controls.pack_start(@tag_condition_box, expand, fill, padding)
		#Add a slider for the age condition.
		@age_condition_slider = Gtk::HScale.new(0, 300, 30)
		condition_controls.pack_start(Gtk::Label.new("Age"), expand, fill, padding)
		condition_controls.pack_start(@age_condition_slider, expand, fill, padding)
		#Add a slider for the proximity condition.
		@proximity_condition_slider = Gtk::HScale.new(1, 100, 10)
		condition_controls.pack_start(Gtk::Label.new("Proximity"), expand, fill, padding)
		condition_controls.pack_start(@proximity_condition_slider, expand, fill, padding)
		#Add the condition controls to the panel.
		control_panel.pack_start(condition_controls, expand, fill, padding)

		#Create a group for the actions.
		action_controls = Gtk::VBox.new(homogeneous, spacing)
		action_controls.pack_start(Gtk::Label.new("Actions"), expand, fill, padding)
		#Add a slider for the accelerate action.
		@acceleration_slider = Gtk::HScale.new(-10, 10, 2)
		action_controls.pack_start(Gtk::Label.new("Accelerate"), expand, fill, padding)
		action_controls.pack_start(@acceleration_slider, expand, fill, padding)
		@acceleration_slider.value = 0
		#Add a slider for the turn action.
		@turn_slider = Gtk::HScale.new(-180, 180, 20)
		action_controls.pack_start(Gtk::Label.new("Turn"), expand, fill, padding)
		action_controls.pack_start(@turn_slider, expand, fill, padding)
		@turn_slider.value = 0
		#Add a slider for the approach angle.
		@approach_slider = Gtk::HScale.new(-180, 180, 20)
		action_controls.pack_start(Gtk::Label.new("Approach"), expand, fill, padding)
		action_controls.pack_start(@approach_slider, expand, fill, padding)
		@approach_slider.value = 0
		#Add a slider for the flee action.
		@flee_slider = Gtk::HScale.new(-180, 180, 20)
		action_controls.pack_start(Gtk::Label.new("Flee"), expand, fill, padding)
		action_controls.pack_start(@flee_slider, expand, fill, padding)
		@flee_slider.value = 0
		#Add a checkbox for the eat action.
		@eat_flag = Gtk::CheckButton.new("Eat")
		action_controls.pack_start(@eat_flag, expand, fill, padding)
		#Add a checkbox for the spawn action.
		#TODO
		#Add a text box for the tag action.
		action_controls.pack_start(Gtk::Label.new("Apply Tag"), expand, fill, padding)
		@tag_action_box = Gtk::Entry.new
		action_controls.pack_start(@tag_action_box, expand, fill, padding)
		#Add the action controls to the panel.
		control_panel.pack_start(action_controls, expand, fill, padding)
		
		#Add the control panel to the interface.
		interface.pack_start(control_panel, expand, fill, padding)
		
		interface
		
	end
	

end


begin
	#The view width.
	WIDTH = 500
	#The view height.
	HEIGHT = 600
	#Run the application.
	application = Application.new(WIDTH, HEIGHT)
	application.main
rescue => exception
	#Print error to STDERR and exit with an abnormal status.
	abort "Error: " + exception.message + exception.backtrace.join("\n")
end
