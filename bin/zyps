#!/usr/local/bin/ruby

# Copyright 2007 Jay McGavren, jay@mcgavren.com.
# 
# This file is part of Zyps.
# 
# Zyps is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


gems_loaded = false
begin
	require 'logger'
	require 'wx'
	require 'zyps'
	require 'zyps/actions'
	require 'zyps/conditions'
	require 'zyps/environmental_factors'
	require 'zyps/remote'
	require 'zyps/views/trails'
	require 'zyps/views/canvas/wx'
rescue LoadError
	if gems_loaded == false
		require 'rubygems'
		gems_loaded = true
		retry
	else
		raise
	end
end


include Zyps


LOG_HANDLE = STDOUT
LOG_LEVEL = Logger::DEBUG


#The Zyps GUI.
class Application < Wx::App


	#Takes a hash with these keys and defaults:
	#	:width => 800
	#	:height => 600
	#	:max_speed => 200
	#	:max_population => 100
	#	:fps => 60
	#	:enclosure => true
	#	:uri => nil
	def initialize(options = {})
	
		super()
	
		#Set up logger.
		@log = Logger.new(LOG_HANDLE)
		@log.level = LOG_LEVEL
		@log.progname = self

		@log.debug "Load options and merge with defaults."
		@options = Configuration.load('options')
		@options = {
			:width => 800,
			:height => 600,
			:max_speed => 200,
			:max_population => 50,
			:fps => 30,
			:enclosure => true,
			:uri => nil,
		}.merge(options)
		@log.debug "options: #{@options.inspect}"
	
	end
	

	#Create GUI objects.
	def on_init
		
		@log.debug "Create the main window."
		frame = Wx::Frame.new(
			nil, #No parent.
			:size => [@options[:width], @options[:height]],
			:title => "Zyps"
		)
		@log.debug "All controls in frame should be resized when frame is."
		frame.sizer = Wx::BoxSizer.new(Wx::HORIZONTAL)
		@log.debug "Application should exit when frame is closed."
		frame.evt_close {on_exit}
		
		@log.debug "Create a view and canvas."
		view = TrailsView.new(
			:width => @options[:width],
			:height => @options[:height],
			:canvas => WxCanvas.new(frame)
		)
		frame.sizer.add(view.canvas.drawing_area, 1, Wx::GROW)
		@log.debug "Set up mouse click/drag handlers for canvas."
		@press_location = nil
		view.canvas.drawing_area.evt_left_down {|event| on_mouse_press(event)}
		view.canvas.drawing_area.evt_left_up {|event| on_mouse_release(event)}
		
		@log.debug "Create an interface."
		@controls = ControlPanel.new(frame)
		@controls.clear_button.evt_button(@controls.clear_button.get_id) do |event|
			@environment.objects = []
		end
		@controls.length_slider.evt_slider(@controls.length_slider.get_id) do |event|
			view.trail_length = @controls.length_slider.value
		end
		@controls.trails_flag.evt_checkbox(@controls.trails_flag.get_id) do |event|
			view.erase_flag = ! @controls.trails_flag.is_checked
		end
		frame.sizer.add(@controls)
		
		@log.debug "Create an environment, and link it to the view."
		@environment = Environment.new
		@environment.add_observer(view)
		
		@log.debug "Set up environmental factors."
		if @options[:enclosure]
			@enclosure = Enclosure.new(
				:left => 0,
				:bottom => 0,
				:top => view.canvas.drawing_area.size.height,
				:right => view.canvas.drawing_area.size.width
			)
			@environment.environmental_factors << @enclosure
			#Resize view and enclosure when canvas changes size.
			view.canvas.drawing_area.evt_size do |event|
				view.height = view.canvas.drawing_area.size.height
				view.width = view.canvas.drawing_area.size.height
				@enclosure.top = view.canvas.drawing_area.size.height
				@enclosure.right = view.canvas.drawing_area.size.width
			end
		end
		@environment.environmental_factors << SpeedLimit.new(@options[:max_speed]) if @options[:max_speed]
		@environment.environmental_factors << PopulationLimit.new(@options[:max_population]) if @options[:max_population]
		
		@log.debug "Set up a creature generator."
		@generator = CreatureGenerator.new(:environment => @environment)
		
		@log.debug "Set up a timer to update the environment."
		milliseconds_per_frame = (1.0 / @options[:fps] * 1000).to_int
		@log.debug "Timer will fire every #{milliseconds_per_frame} milliseconds."
		timer_id = Wx::ID_HIGHEST + 1
		timer = Wx::Timer.new(self, timer_id)
		evt_timer(timer_id) do
			@environment.interact
			#Keeps dead objects from accumulating and causing hiccups later.
			GC.start
		end
		timer.start(milliseconds_per_frame)
		
		@log.debug "Display GUI."
		frame.show
	
	end

	
	#Save config and shut down.
	def on_exit
		Configuration.save('options', @options)
		exit
	end
	
	
	#When mouse button pressed, record location for use in release event handler.
	def on_mouse_press(event)
		@log.debug "Mouse pressed at #{event.x}, #{event.y}."
		@press_location = Location.new(event.x, event.y)
	end
	
	
	#Create a creature on button release.
	def on_mouse_release(event)
		@log.debug "Mouse released at #{event.x}, #{event.y}."
		#Ensure the mouse was pressed within the canvas.
		if @press_location
			#Create creature at release location.
			@release_location = Location.new(event.x, event.y)
			@log.debug "Release location: #{@release_location.inspect}"
			@environment.objects << @generator.create_creature(
				:x => event.x,
				:y => event.y,
				:speed => Utility.find_distance(@press_location, @release_location) * 2, #Use distance dragged as speed.
				:pitch => Utility.find_angle(@press_location, @release_location), #Move in direction of drag.
				:turn => @controls.turn_flag.is_checked,
				:approach => @controls.approach_flag.is_checked,
				:flee => @controls.flee_flag.is_checked,
				:push => @controls.push_flag.is_checked,
				:pull => @controls.pull_flag.is_checked,
				:breed => @controls.breed_flag.is_checked,
				:eat => @controls.eat_flag.is_checked
			)
			#Nullify press location, as it is no longer applicable.
			@press_location = nil
		end
	end
	
	
end



#TODO
module Configuration
	def Configuration.load(name)
		{}
	end
	def Configuration.save(name, options)
	end
end



#Controls for manipulating the environment.
class ControlPanel < Wx::Panel


	attr_accessor :turn_flag
	attr_accessor :approach_flag
	attr_accessor :flee_flag
	attr_accessor :push_flag
	attr_accessor :pull_flag
	attr_accessor :breed_flag
	attr_accessor :eat_flag
	attr_accessor :length_slider
	attr_accessor :trails_flag
	attr_accessor :clear_button


	def initialize(parent)
	
		super(parent)
		self.sizer = Wx::BoxSizer.new(Wx::VERTICAL)

		action_controls = add_panel(self)
		add_label(action_controls, :label => "Actions")
		@turn_flag = add_check_box(action_controls, :label => "Turn")
		@approach_flag = add_check_box(action_controls, :label => "Chase")
		@flee_flag = add_check_box(action_controls, :label => "Flee")
		@push_flag = add_check_box(action_controls, :label => "Push")
		@pull_flag = add_check_box(action_controls, :label => "Pull")
		@breed_flag = add_check_box(action_controls, :label => "Breed")
		@eat_flag = add_check_box(action_controls, :label => "Eat")
		
		environment_controls = add_panel(self)
		add_label(environment_controls, :label => "Length")
		@length_slider = add_slider(environment_controls, :min_value => 2, :max_value => 100)
		@length_slider.value = 5
		@trails_flag = add_check_box(environment_controls, :label => "Trails")
		@clear_button = add_button(environment_controls, :label => "Clear")
		
	end


	private
	
		#Other methods will call this with their particular type of control to add.
		#Adds control to parent's sizer if it has one.
		#Returns the control.
		def add_control(control)
			begin
				control.parent.sizer.add(control)
			rescue RuntimeError
				#Parent had no sizer; take no action.
				#Can't find another way to test for presence of a sizer as of wxRuby 1.9.2.
			end
			#Return the object.
			control
		end
	
		#Create a check box with the given label, and add it to the given container.
		def add_check_box(parent, options = {})
			add_control(Wx::CheckBox.new(parent, options))
		end

		#Create the given label, and add it to the given container.
		def add_label(parent, options = {})
			add_control(Wx::StaticText.new(parent, options))
		end
		
		#Create a slider control with the given options, and add it to the given container.
		def add_slider(parent, options = {})
			add_control(Wx::Slider.new(parent, options))
		end
		
		#Create a button with the given options, and add it to the given container.
		def add_button(parent, options = {})
			add_control(Wx::Button.new(parent, options))
		end
		
		#Create a panel, and add it to the given container.
		#Takes a hash with the following keys and defaults, in addition to those taken by Wx::Panel.new():
		#	:sizer => Wx::BoxSizer.new(Wx::VERTICAL)
		def add_panel(parent, options = {})
			options = {
				:sizer => Wx::BoxSizer.new(Wx::VERTICAL),
			}.merge(options)
			panel = Wx::Panel.new(parent, options)
			panel.sizer = options[:sizer]
			add_control(panel)
		end
		
		
end



#Creates Creature objects.
class CreatureGenerator


	#Environment creatures will be placed in.
	attr_accessor :environment
	#Default size of new creatures.
	attr_accessor :default_size
	#Default required proximity for actions.
	attr_accessor :default_proximity
	#Rate of new TurnActions.
	attr_accessor :turn_rate
	#Acceleration rate of new ApproachActions.
	attr_accessor :approach_rate
	#Acceleration rate of new FleeActions.
	attr_accessor :flee_rate
	#Strength of new PullActions.
	attr_accessor :pull_strength
	#Strength of new PushActions.
	attr_accessor :push_strength

	
	#Takes a hash with these keys and defaults:
	#	:environment => nil
	#	:default_size => 5
	#	:default_proximity => 200
	#	:approach_rate => 200
	#	:flee_rate => :approach_rate
	#	:push_strength => :approach_rate * 2
	#	:pull_strength => :push_strength * 0.75
	#	:turn_rate => :approach_rate * 1.1
	#	:turn_angle => 90
	#	:breed_rate => 10
	def initialize(options = {})
	
		#Set up logger.
		@log = Logger.new(LOG_HANDLE)
		@log.level = LOG_LEVEL
		@log.progname = self

		options = {
			:default_size => 5,
			:default_proximity => 200,
			:approach_rate => 200,
			:turn_angle => 90,
			:breed_rate => 10,
		}.merge(options)
		@log.debug "options: #{@options.inspect}"
		
		@environment = options[:environment]
		@default_size = options[:default_size]
		@default_proximity = options[:default_proximity]
		@approach_rate = options[:approach_rate]
		@turn_angle = options[:turn_angle]
		@breed_rate = options[:breed_rate]
		@flee_rate = options[:flee_rate] || @approach_rate * 2
		@push_strength = options [:push_strength] || @approach_rate * 2
		@pull_strength = options[:pull_strength] || @push_strength * 0.75
		@turn_rate = options[:turn_rate] || @approach_rate * 1.1
		
	end
	
	
	#Create a creature with the given attributes and behaviors.
	#Takes a hash with these keys and defaults:
	#	:x => 0,
	#	:y => 0,
	#	:speed => 1,
	#	:pitch => 0,
	#	:size => @default_size,
	#	:action_proximity => @default_proximity,
	#	:turn => false,
	#	:approach => false,
	#	:flee => false,
	#	:push => false,
	#	:pull => false,
	#	:breed => false,
	#	:eat => false,
	def create_creature(options = {})
	
		options = {
			:x => 0,
			:y => 0,
			:speed => 1,
			:pitch => 0,
			:size => @default_size,
			:action_proximity => @default_proximity,
			:turn => false,
			:approach => false,
			:flee => false,
			:push => false,
			:pull => false,
			:breed => false,
			:eat => false,
		}.merge(options)
		@log.debug "options: #{@options.inspect}"
		
		#Create a creature.
		creature = Creature.new(
			:location => Location.new(options[:x], options[:y]),
			:vector => Vector.new(options[:speed], options[:pitch]),
			:size => options[:size]
		)
		
		#Set up actions and merge colors according to selected behaviors.
		color = Color.new(0.25, 0.25, 0.25)
		if options[:turn]
			color.blue += 1
			creature.behaviors << Behavior.new(
				:actions => [TurnAction.new(@turn_rate, @turn_angle)],
				:conditions => [ProximityCondition.new(options[:action_proximity] * 2)]
			)
		end
		if options[:approach]
			color.red += 1
			creature.behaviors << Behavior.new(
				:actions => [ApproachAction.new(@approach_rate)],
				:conditions => [ProximityCondition.new(options[:action_proximity])]
			)
		end
		if options[:flee]
			color.red += 0.5; color.green += 0.5 #Yellow.
			creature.behaviors << Behavior.new(
				:actions => [FleeAction.new(@flee_rate)],
				:conditions => [ProximityCondition.new(options[:action_proximity] * 0.5)]
			)
		end
		if options[:push]
			color.red += 0.5; color.blue += 0.5 #Purple.
			creature.behaviors << Behavior.new(
				:actions => [PushAction.new(@push_strength)],
				:conditions => [ProximityCondition.new(options[:action_proximity] * 0.25)]
			)
		end
		if options[:pull]
			color.blue += 0.75; color.green += 0.75 #Aqua.
			creature.behaviors << Behavior.new(
				:actions => [PullAction.new(@pull_strength)],
				:conditions => [ProximityCondition.new(options[:action_proximity] * 0.75)]
			)
		end
		if options[:breed]
			color.green -= 0.1 #Make a bit redder.
			color.blue -= 0.1
			creature.behaviors << Behavior.new(
				:actions => [BreedAction.new(@environment, @breed_rate)],
				:conditions => [CollisionCondition.new] #The default ProximityCondition won't do.
			)
		end
		if options[:eat]
			color.green += 1
			creature.behaviors << Behavior.new(
				:actions => [EatAction.new(@environment)],
				:conditions => [
					CollisionCondition.new, #The default ProximityCondition won't do.
					StrengthCondition.new #The eater should be as strong or stronger than its dinner.
				] 
			)
		end
		
		creature.color = color
		
		@log.debug "Created creature: #{creature.inspect}"
		
		creature
		
	end
	
	
end


Application.new.main_loop
