#!/usr/local/bin/ruby

# Copyright 2007 Jay McGavren, jay@mcgavren.com.
# 
# This file is part of Zyps.
# 
# Zyps is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


begin
	require 'zyps'
	require 'zyps/actions'
	require 'zyps/conditions'
	require 'zyps/environmental_factors'
	require 'zyps/views/trails'
rescue LoadError
	require 'rubygems'
	require 'zyps'
	require 'zyps/actions'
	require 'zyps/conditions'
	require 'zyps/environmental_factors'
	require 'zyps/views/trails'
end



class Application

	#Create app window, game environment, and view.
	def initialize(width, height)
		
		@width, @height = width, height
		@birth_rate = 1
		@fps = 30.0
		
		#Create a window, and set GTK up to quit when it is closed.
		window = Gtk::Window.new
		window.signal_connect("delete_event") {false}
		window.signal_connect("destroy") {Gtk.main_quit}
		
		#Set up controls.
		window.add(create_controls)
	
		#Show all widgets.
		window.show_all
		
		#Create environment.
		@environment = Environment.new
		
		#Point view at environment.
		@environment.add_observer(@view)
		
	end
	
	
	def main
	
	
		#Keep all objects within a boundary.
		enclosure = Enclosure.new
		enclosure.left = 0
		enclosure.bottom = 0
		enclosure.top = @height
		enclosure.right = @width
		@environment.environmental_factors << enclosure

		#Create thread to update environment.
		thread = Thread.new do
		
			begin
			
				drawing_clock = Clock.new
				time_per_frame = 1.0 / @fps
				
				loop do
				
					@environment.interact
					
					#Control population.
					@environment.objects.shift while @environment.objects.length > 25
					
					#Determine how much time is left in this frame.
					time_left_in_frame = (time_per_frame) - drawing_clock.elapsed_time
					#Sleep for the remaining time.
					if time_left_in_frame > 0
						sleep time_left_in_frame
					#Skip a frame if things are going too slow.
					else
						sleep time_per_frame
					end
					
				end
				
			rescue Exception => exception
				puts exception, exception.backtrace
			end
			
		end
		
		#Activate the GUI.
		Gtk.main
		
	end
	
	
	#Create a view and controls.
	def create_controls(width = @width, height = @height, homogeneous = false, spacing = 0, expand = false, fill = false, padding = 0)
	
		#Create a container for the view and controls.
		interface = Gtk::HBox.new(homogeneous, spacing)
		
		#Add view to interface.
		@view = TrailsView.new(width, height)
		interface.pack_start(@view.canvas, expand, fill, padding)
		#Get mouse events on view.
		@view.canvas.add_events(Gdk::Event::BUTTON_PRESS_MASK)
		@view.canvas.signal_connect("button-press-event") do |canvas, event|
			@press_location = Location.new(event.x, event.y)
		end
		@view.canvas.add_events(Gdk::Event::BUTTON_RELEASE_MASK)
		@view.canvas.signal_connect("button-release-event") do |canvas, event|
			@release_location = Location.new(event.x, event.y)
			creature = Creature.new(
				'',
				@release_location,
				Color.new(@red_slider.value, @green_slider.value, @blue_slider.value),
				Vector.new(
					Utility.find_distance(@press_location, @release_location) * 2, #Use distance dragged as speed.
					Utility.find_angle(@press_location, @release_location) #Move in direction of drag.
				),
				0,
				1
			)
			behavior = Behavior.new
			behavior.actions << AccelerateAction.new(1) if @accelerate_flag.active?
			behavior.actions << TurnAction.new(90) if @turn_flag.active?
			behavior.actions << ApproachAction.new(creature.vector, 90) if @approach_flag.active?
			behavior.actions << FleeAction.new(creature.vector) if @flee_flag.active?
			behavior.actions << BlendAction.new(creature.color) if @paint_flag.active?
			creature.behaviors << behavior
			@environment.objects << creature
		end
		
		#Create a VBox for all controls.
		control_panel = Gtk::VBox.new(homogeneous, spacing)
	
		#Create a group for the new object's attributes.
		attribute_controls = Gtk::VBox.new(homogeneous, spacing)
		
		#Add sliders for the color components.
		attribute_controls.pack_start(Gtk::Label.new("Color"), expand, fill, padding)
		attribute_controls.pack_start(Gtk::Label.new("R"), expand, fill, padding)
		@red_slider = Gtk::HScale.new(0, 1, 0.1)
		attribute_controls.pack_start(@red_slider, expand, fill, padding)
		attribute_controls.pack_start(Gtk::Label.new("G"), expand, fill, padding)
		@green_slider = Gtk::HScale.new(0, 1, 0.1)
		attribute_controls.pack_start(@green_slider, expand, fill, padding)
		attribute_controls.pack_start(Gtk::Label.new("B"), expand, fill, padding)
		@blue_slider = Gtk::HScale.new(0, 1, 0.1)
		attribute_controls.pack_start(@blue_slider, expand, fill, padding)
		@red_slider.value, @green_slider.value, @blue_slider.value = 1, 1, 1
				
		#Add the attribute controls to the panel.
		control_panel.pack_start(attribute_controls, expand, fill, padding)
		
		#Create a group for the actions.
		action_controls = Gtk::VBox.new(homogeneous, spacing)
		action_controls.pack_start(Gtk::Label.new("Actions"), expand, fill, padding)
		@accelerate_flag = Gtk::CheckButton.new("Accelerate")
		action_controls.pack_start(@accelerate_flag, expand, fill, padding)
		@turn_flag = Gtk::CheckButton.new("Turn")
		action_controls.pack_start(@turn_flag, expand, fill, padding)
		@approach_flag = Gtk::CheckButton.new("Approach")
		action_controls.pack_start(@approach_flag, expand, fill, padding)
		@flee_flag = Gtk::CheckButton.new("Flee")
		action_controls.pack_start(@flee_flag, expand, fill, padding)
		@eat_flag = Gtk::CheckButton.new("Eat")
		action_controls.pack_start(@eat_flag, expand, fill, padding)
		@paint_flag = Gtk::CheckButton.new("Paint")
		action_controls.pack_start(@paint_flag, expand, fill, padding)
		#Add the action controls to the panel.
		control_panel.pack_start(action_controls, expand, fill, padding)
		
		#Add the control panel to the interface.
		interface.pack_start(control_panel, expand, fill, padding)
		
		interface
		
	end
	

end


begin
	#The view width.
	WIDTH = 500
	#The view height.
	HEIGHT = 600
	#Run the application.
	application = Application.new(WIDTH, HEIGHT)
	application.main
rescue => exception
	#Print error to STDERR and exit with an abnormal status.
	abort "Error: " + exception.message + exception.backtrace.join("\n")
end
