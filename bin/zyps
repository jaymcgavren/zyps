#!/usr/local/bin/ruby

# Copyright 2007 Jay McGavren, jay@mcgavren.com.
# 
# This file is part of Zyps.
# 
# Zyps is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


begin
	require 'zyps'
	require 'zyps/actions'
	require 'zyps/conditions'
	require 'zyps/environmental_factors'
	require 'zyps/views/trails'
rescue LoadError
	require 'rubygems'
	require 'zyps'
	require 'zyps/actions'
	require 'zyps/conditions'
	require 'zyps/environmental_factors'
	require 'zyps/views/trails'
end



class Application

	#Tags to randomly choose from.
	attr_accessor :tag_pool
	#Colors to randomly choose from.
	attr_accessor :color_pool
	#Seconds between creature creation.
	attr_accessor :birth_rate
	
	#Create app window, game environment, and view.
	def initialize(width, height)
		
		@width, @height = width, height
		@birth_rate = 1
		@fps = 30.0
		
		#Create a window, and set GTK up to quit when it is closed.
		window = Gtk::Window.new
		window.signal_connect("delete_event") {false}
		window.signal_connect("destroy") {Gtk.main_quit}
		
		#Set up controls.
		window.add(create_controls)
	
		#Show all widgets.
		window.show_all
		
		#Create environment.
		@environment = Environment.new
		
		#Point view at environment.
		@environment.add_observer(@view)
		
	end
	
	
	def main
	
	
		#Keep all objects within a boundary.
		enclosure = Enclosure.new
		enclosure.left = 0
		enclosure.bottom = 0
		enclosure.top = @height
		enclosure.right = @width
		@environment.environmental_factors << enclosure

		#Create thread to update environment.
		thread = Thread.new do
		
			begin
			
				drawing_clock = Clock.new
				time_per_frame = 1.0 / @fps
				
				loop do
				
					@environment.interact
					
					#Control population.
					@environment.objects.shift while @environment.objects.length > 25
					
					#Determine how much time is left in this frame.
					time_left_in_frame = (time_per_frame) - drawing_clock.elapsed_time
					#Sleep for the remaining time.
					if time_left_in_frame > 0
						sleep time_left_in_frame
					#Skip a frame if things are going too slow.
					else
						sleep time_per_frame
					end
					
				end
				
			rescue Exception => exception
				puts exception, exception.backtrace
			end
			
		end
		
		#Activate the GUI.
		Gtk.main
		
	end
	
	
	#Create a view and controls.
	def create_controls(width = @width, height = @height, homogeneous = false, spacing = 0, expand = false, fill = false, padding = 0)
	
		#Create a container for the view and controls.
		interface = Gtk::HBox.new(homogeneous, spacing)
		
		#Add view to interface.
		@view = TrailsView.new(width, height)
		interface.pack_start(@view.canvas, expand, fill, padding)
		#Get mouse events on view.
		@view.canvas.add_events(Gdk::Event::BUTTON_PRESS_MASK)
		@view.canvas.signal_connect("button-press-event") do |canvas, event|
			@press_location = Location.new(event.x, event.y)
		end
		@view.canvas.add_events(Gdk::Event::BUTTON_RELEASE_MASK)
		@view.canvas.signal_connect("button-release-event") do |canvas, event|
			@release_location = Location.new(event.x, event.y)
			creature = Creature.new(
				'',
				@release_location,
				Color.new(@red_slider.value, @green_slider.value, @blue_slider.value),
				Vector.new(
					Utility.find_distance(@press_location, @release_location) * 2, #Use distance dragged as speed.
					Utility.find_angle(@press_location, @release_location) #Move in direction of drag.
				),
				0,
				1,
				@tags_box.text.split(/,\s*/)
			)
			behavior = Behavior.new
			condition_tags = @tag_condition_box.text
			condition_tags.split(/,\s*/).each do |tag|
				behavior.conditions << TagCondition.new(tag)
			end
			proximity = @proximity_condition_slider.value
			behavior.conditions << ProximityCondition.new(proximity) if proximity > 0
			age = @age_condition_slider.value
			behavior.conditions << AgeCondition.new(age) if age > 0
			acceleration = @acceleration_slider.value
			behavior.actions << AccelerateAction.new(acceleration) if acceleration != 0
			turn = @turn_slider.value
			behavior.actions << TurnAction.new(turn) if turn != 0
			approach_angle = @approach_slider.value
			behavior.actions << ApproachAction.new(Vector.new(5, creature.vector.pitch), approach_angle) if approach_angle > 0
			flee_angle = @flee_slider.value
			behavior.actions << FleeAction.new(Vector.new(5, creature.vector.pitch), flee_angle) if flee_angle > 0
			behavior.actions << EatAction.new(@environment) if @eat_flag.active?
			apply_tags = @tag_action_box.text
			apply_tags.split(/,\s*/).each do |tag|
				behavior.actions << TagAction.new(tag)
			end
			creature.behaviors << behavior
			@environment.objects << creature
		end
		
		#Create a VBox for all controls.
		control_panel = Gtk::VBox.new(homogeneous, spacing)
	
		#Create a group for the new object's attributes.
		attribute_controls = Gtk::VBox.new(homogeneous, spacing)
		
		#Add sliders for the color components.
		attribute_controls.pack_start(Gtk::Label.new("Color"), expand, fill, padding)
		attribute_controls.pack_start(Gtk::Label.new("R"), expand, fill, padding)
		@red_slider = Gtk::HScale.new(0, 1, 0.1)
		attribute_controls.pack_start(@red_slider, expand, fill, padding)
		attribute_controls.pack_start(Gtk::Label.new("G"), expand, fill, padding)
		@green_slider = Gtk::HScale.new(0, 1, 0.1)
		attribute_controls.pack_start(@green_slider, expand, fill, padding)
		attribute_controls.pack_start(Gtk::Label.new("B"), expand, fill, padding)
		@blue_slider = Gtk::HScale.new(0, 1, 0.1)
		attribute_controls.pack_start(@blue_slider, expand, fill, padding)
		@red_slider.value, @green_slider.value, @blue_slider.value = 1, 1, 1
				
		#Add a text box for the tags.
		attribute_controls.pack_start(Gtk::Label.new("Tags"), expand, fill, padding)
		@tags_box = Gtk::Entry.new
		attribute_controls.pack_start(@tags_box, expand, fill, padding)
		
		#Add the attribute controls to the panel.
		control_panel.pack_start(attribute_controls, expand, fill, padding)
		
		#Create a group for the conditions.
		condition_controls = Gtk::VBox.new(homogeneous, spacing)
		condition_controls.pack_start(Gtk::Label.new("Target"), expand, fill, padding)
		#Add a text box for the tag condition.
		condition_controls.pack_start(Gtk::Label.new("Tags"), expand, fill, padding)
		@tag_condition_box = Gtk::Entry.new
		condition_controls.pack_start(@tag_condition_box, expand, fill, padding)
		#Add a slider for the age condition.
		@age_condition_slider = Gtk::HScale.new(0, 300, 30)
		condition_controls.pack_start(Gtk::Label.new("Age"), expand, fill, padding)
		condition_controls.pack_start(@age_condition_slider, expand, fill, padding)
		#Add a slider for the proximity condition.
		@proximity_condition_slider = Gtk::HScale.new(1, 100, 10)
		condition_controls.pack_start(Gtk::Label.new("Proximity"), expand, fill, padding)
		condition_controls.pack_start(@proximity_condition_slider, expand, fill, padding)
		#Add the condition controls to the panel.
		control_panel.pack_start(condition_controls, expand, fill, padding)

		#Create a group for the actions.
		action_controls = Gtk::VBox.new(homogeneous, spacing)
		action_controls.pack_start(Gtk::Label.new("Actions"), expand, fill, padding)
		#Add a slider for the accelerate action.
		@acceleration_slider = Gtk::HScale.new(-10, 10, 2)
		action_controls.pack_start(Gtk::Label.new("Accelerate"), expand, fill, padding)
		action_controls.pack_start(@acceleration_slider, expand, fill, padding)
		@acceleration_slider.value = 0
		#Add a slider for the turn action.
		@turn_slider = Gtk::HScale.new(-180, 180, 20)
		action_controls.pack_start(Gtk::Label.new("Turn"), expand, fill, padding)
		action_controls.pack_start(@turn_slider, expand, fill, padding)
		@turn_slider.value = 0
		#Add a slider for the approach angle.
		@approach_slider = Gtk::HScale.new(-180, 180, 20)
		action_controls.pack_start(Gtk::Label.new("Approach"), expand, fill, padding)
		action_controls.pack_start(@approach_slider, expand, fill, padding)
		@approach_slider.value = 0
		#Add a slider for the flee action.
		@flee_slider = Gtk::HScale.new(-180, 180, 20)
		action_controls.pack_start(Gtk::Label.new("Flee"), expand, fill, padding)
		action_controls.pack_start(@flee_slider, expand, fill, padding)
		@flee_slider.value = 0
		#Add a checkbox for the eat action.
		@eat_flag = Gtk::CheckButton.new("Eat")
		action_controls.pack_start(@eat_flag, expand, fill, padding)
		#Add a checkbox for the spawn action.
		#TODO
		#Add a text box for the tag action.
		action_controls.pack_start(Gtk::Label.new("Apply Tag"), expand, fill, padding)
		@tag_action_box = Gtk::Entry.new
		action_controls.pack_start(@tag_action_box, expand, fill, padding)
		#Add the action controls to the panel.
		control_panel.pack_start(action_controls, expand, fill, padding)
		
		#Add the control panel to the interface.
		interface.pack_start(control_panel, expand, fill, padding)
		
		interface
		
	end
	

end


begin
	#The view width.
	WIDTH = 500
	#The view height.
	HEIGHT = 600
	#Run the application.
	application = Application.new(WIDTH, HEIGHT)
	application.main
rescue => exception
	#Print error to STDERR and exit with an abnormal status.
	abort "Error: " + exception.message + exception.backtrace.join("\n")
end
