#!/usr/local/bin/ruby

# Copyright 2007 Jay McGavren, jay@mcgavren.com.
# 
# This file is part of Zyps.
# 
# Zyps is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


gems_loaded = false
begin
	require 'logger'
	require 'wx'
	require 'zyps'
	require 'zyps/actions'
	require 'zyps/conditions'
	require 'zyps/environmental_factors'
	require 'zyps/views/trails'
	require 'zyps/views/canvas/wx'
rescue LoadError
	if gems_loaded == false
		require 'rubygems'
		gems_loaded = true
		retry
	else
		raise
	end
end


include Zyps


LOG_LEVEL = Logger::WARN
LOG_HANDLE = STDOUT


class Demo < Wx::App


	#The view width.
	WIDTH = 400
	#The view height.
	HEIGHT = 300
	#Number of frames per second.
	FRAMES_PER_SECOND = 30
	#Default size of game objects.
	DEFAULT_OBJECT_SIZE = 78.5 #5 units in radius.

	
	#Initialize an Environment and a View.  Then run the demos.
	def on_init
	
		@log = Logger.new(LOG_HANDLE)
		@log.level = LOG_LEVEL
		@log.progname = self
		
		say "We're using wxRuby as the GUI framework for this demo."
		say "First, we need to create a Frame (window) to hold everything."
		frame = Wx::Frame.new(nil, :size => [WIDTH, HEIGHT], :title => "Zyps Demo")
		frame.evt_close {|event| exit}
		frame.show
		
		say "Zyps environments are displayed using Views."
		say "A TrailsView shows game objects with little light trails behind them."
		view = TrailsView.new(
			:width => WIDTH,
			:height => HEIGHT
		)
		say "We also assign the View a Canvas to draw to."
		say "Since our framework is wxWidgets, we'll use a WxCanvas."
		view.canvas = WxCanvas.new(frame)
		
		say "The world is called an Environment in Zyps.  Let's create a new one."
		@environment = Environment.new
		say "We tell the View to display our Environment by adding it as an Observer."
		@environment.add_observer(view)
		say "We'll also add this application as an observer, to track the number of updates."
		@update_count = 0
		@environment.add_observer(self)
		
		say "We want to update the environment #{FRAMES_PER_SECOND} times per second."
		milliseconds_per_frame = (1.0 / FRAMES_PER_SECOND * 1000).to_int
		say "So, we'll set up a timer to fire every #{milliseconds_per_frame} milliseconds."
		timer_id = Wx::ID_HIGHEST + 1
		timer = Wx::Timer.new(self, timer_id)
		say "The timer will trigger the environment update."
		say "We also call the Ruby garbage collector with each update."
		say "This keeps dead objects from accumulating and causing hiccups later."
		evt_timer(timer_id) do
			@environment.interact
			GC.start
		end
		timer.start(milliseconds_per_frame)
		
	end
	
	
	#Watch for environment updates.
	#After a certain number, run the next demo.
	def update(environment)
		case @update_count
			when 0:
				say "-" * 30
				test_render
			when 100:
				test_render_2
				say "-" * 30
			when 200:
				@environment.objects = []
				test_environmental_factors
			when 300:
				test_environmental_factors_2
				say "-" * 30
			when 400:
				@environment.objects = []
				@environment.environmental_factors = []
				test_behaviors
			when 500:
				test_behaviors_2
				say "-" * 30
			when 600:
				@environment.objects = []
				test_change_color
				say "-" * 30
			when 800:
				@environment.objects = []
				test_accelerate
				say "-" * 30
			when 1000:
				@environment.objects = []
				test_turn
				say "-" * 30
			when 1200:
				@environment.objects = []
				test_approach
				say "-" * 30
			when 1400:
				@environment.objects = []
				test_flee
				say "-" * 30
			when 1600:
				@environment.objects = []
				test_eat
				say "-" * 30
			when 1800:
				finish
		end
		@update_count += 1
	end

	
	#Populate an environment with the given number of creatures.
	def populate(environment, count = 50)
		@log.debug "Add #{count} creatures to #{environment}."
		count.times do |i|
			multiplier = i / count.to_f
			environment.objects << Creature.new(
				:name => i,
				:location => Location.new(multiplier * WIDTH, multiplier * HEIGHT),
				:color => Color.new(multiplier, 1 - multiplier, multiplier / 2 + 0.5),
				:vector => Vector.new(100 * multiplier, multiplier * 360),
				:size => DEFAULT_OBJECT_SIZE
			)
		end
	end
	
	
	#Demonstrates drawing an environment and changing its size.
	def test_render

		say("The things in an Environment are called GameObjects.  Each object has:")
		object = GameObject.new
		say("...a name")
		object.name = "Huey"
		say("...a size")
		object.size = DEFAULT_OBJECT_SIZE
		say("...a Location with x and y coordiates")
		object.location = Location.new(WIDTH/2, HEIGHT/2)
		say("...a Color with red, green and blue components ranging from 0 to 1")
		object.color = Color.new(1, 0, 0)
		say("...and a Vector giving its speed and an angle from 0 to 360.")
		object.vector = Vector.new(10, 45)
		
		say("Once your object is ready, add it to the environment.")
		@environment.objects << object

	end
	
	def test_render_2
	
		say("Let's add a couple more objects with different colors and vectors.")
		@environment.objects << GameObject.new(
			:name => "Duey",
			:location => Location.new(WIDTH/2, HEIGHT/2),
			:color => Color.new(0, 1, 0),
			:vector => Vector.new(20, 135),
			:size => DEFAULT_OBJECT_SIZE * 2
		)
		@environment.objects << GameObject.new(
			:name => "Louie",
			:location => Location.new(WIDTH/2, HEIGHT/2),
			:color => Color.new(0, 0, 1),
			:vector => Vector.new(30, 225),
			:size => DEFAULT_OBJECT_SIZE * 3
		)
				
	end
	
	
	#Demonstrates environmental factors by adding gravity to the environment.
	def test_environmental_factors

		populate(@environment)
		
		say("Without gravity, objects just travel on forever.")
	
	end
	
	def test_environmental_factors_2
	
		say("Let's add a new EnvironmentalFactor to simulate gravity.")
		gravity = Gravity.new(200)
		
		say("We add gravity to the Environment.")
		@environment.environmental_factors << gravity
		
		say("Everything immediately drops.")
		
	end


	#Demonstrates creature behaviors.
	def test_behaviors

		populate(@environment)
		
		say("Let's add a Behavior to our creatures.")
		chase = Behavior.new
		
		say("A Behavior has one or more Action objects that define an action to take on the current target.")
		say("We'll add an Action that makes the creatures head straight toward their target.")
		chase.actions << FaceAction.new
		
		say("A Behavior also has one or more Condition objects.")
		say("Unless every Condition is true, the action(s) won't be carried out.")
		say("So that they don't target every creature on the screen, we'll add a condition to the behavior saying the target must have the label 'food'.")
		chase.conditions << TagCondition.new("food")
		
		say("We'll apply this behavior to all creatures currently in the environment.")
		@environment.objects.each {|creature| creature.behaviors << chase}
		
	end
	
	def test_behaviors_2
		
		say("Then we'll toss a piece of food into the environment.")
		say("(It's just a GameObject with the tag 'food'.)")
		@environment.objects << GameObject.new(
			:name => "target",
			:location => Location.new(WIDTH / 2, HEIGHT / 2),
			:color => Color.new(1, 1, 1),
			:vector => Vector.new(30, 315),
			:size => DEFAULT_OBJECT_SIZE * 2, #Size.
			:tags => ["food"]
		)
		
		say("Now there's a target in the environment for which the condition is true.")
		say("All the Creatures will turn and chase it.")
		
	end


	#A Creature that changes the colors of other objects.
	class Morpher < Creature
		#Changes an object's color.
		def initialize(*arguments)
			super
			morph = Behavior.new
			#Shift the target's color to match the creature's.
			morph.actions << BlendAction.new(self.color)
			#Act only on nearby targets.
			morph.conditions << ProximityCondition.new(50)
			@behaviors << morph
		end
	end

	#Demonstrates changing object colors.
	def test_change_color

		populate(@environment)
		
		say("Creatures can influence any attribute of their target, such as its color.")
		say("This demo includes a Morpher class, which is a type of Creature.")
		say("Morphers are created with a single behavior, which shifts the color of any nearby target to match the Morpher's color.")
		
		say("Let's place a red Morpher...")
		@environment.objects << Morpher.new(
			:location => Location.new(0, 100),
			:color => Color.new(1, 0, 0),
			:vector => Vector.new(100, 0),
			:size => DEFAULT_OBJECT_SIZE
		)
		say("a green one...")
		@environment.objects << Morpher.new(
			:location => Location.new(0, 150),
			:color => Color.new(0, 1, 0),
			:vector => Vector.new(200, 0),
			:size => DEFAULT_OBJECT_SIZE
		)
		say("and a blue one...")
		@environment.objects << Morpher.new(
			:location => Location.new(0, 200),
			:color => Color.new(0, 0, 1),
			:vector => Vector.new(300, 0),
			:size => DEFAULT_OBJECT_SIZE
		)
		
		say("...and see what they do.")
		
	end


	#Demonstrates altering object speed.
	def test_accelerate

		say("Here are some Creatures, just plodding along.")
		populate(@environment)
		
		say("We're going to have them pick up the pace.")
		say("We add a Behavior with an AccelerateAction to all the creatures.")
		say("This AccelerateAction specifies they should increase their speed by 50 units/second.")
		@environment.objects.each do |creature|
			accelerate = Behavior.new
			accelerate.actions << AccelerateAction.new(50)
			creature.behaviors << accelerate
		end
			
	end


	#Demonstrates altering object vectors.
	def test_turn

		populate(@environment)
		
		say("This time we'll use the TurnAction class.")
		say("We tell each creature it should turn 90 degrees.")
		@environment.objects.each do |creature|
			turn = Behavior.new
			turn.actions << TurnAction.new(100, 90)
			creature.behaviors << turn
		end
		
	end


	#Demonstrates adding vectors.
	def test_approach

		populate(@environment, 50)
		
		say("When your car skids on ice, you might steer in a different direction, but you're going to keep following your original vector for a while.")
		say("Our ApproachAction adds the vector the creature WANTS to follow to the vector it's ACTUALLY following.")
		say("We add a behavior with an ApproachAction to all creatures...")
		say("We also add a condition that it should only target food.")
		@environment.objects.each do |creature|
			approach = Behavior.new
			approach.actions << ApproachAction.new(360, creature.vector)
			approach.conditions << TagCondition.new("food")
			creature.behaviors << approach
		end
		
		say("Add a target...")
		@environment.objects << Creature.new(
			:name => "target",
			:location => Location.new(WIDTH / 2, HEIGHT / 3),
			:vector => Vector.new(10, 0),
			:size => DEFAULT_OBJECT_SIZE,
			:tags => ["food"]
		)
		
		say("And watch them all TRY to catch it.")
		
	end



	#Demonstrates adding vectors.
	def test_flee

		populate(@environment, 50)
		
		say("A FleeAction is just like an ApproachAction, but we head in the OPPOSITE direction.")
		@environment.objects.each do |creature|
			flee = Behavior.new
			flee.actions << FleeAction.new(360, creature.vector)
			flee.conditions << TagCondition.new("predator")
			creature.behaviors << flee
		end
		
		@environment.objects << Creature.new(
			:name => "hunter",
			:location => Location.new(WIDTH / 2, HEIGHT / 2),
			:vector => Vector.new(10, 0),
			:size => DEFAULT_OBJECT_SIZE,
			:tags => ["predator"]
		)
		
	end

	
	#Demonstrates keeping a reference to an Environment so a Creature can alter it.
	def test_eat
	
		populate(@environment)
		
		say("Most games are all about destruction, but there hasn't been much so far.")
		say("Let's create a creature that causes some havoc.")
		predator = Creature.new(
			:location => Location.new(0, 150),
			:color => Color.new(0, 1, 0),
			:vector => Vector.new(200, 0), 
			:size => DEFAULT_OBJECT_SIZE * 5
		)
		
		say("The EatAction eats targets by removing them from their environment.")
		say("Creatures and their Actions normally know nothing about the Environment they belong to, so EatAction takes an Environment in its constructor.")
		say("EatAction finds the target in Environment.objects and removes it.")
		action = EatAction.new(@environment)
		
		say("Create a behavior...")
		behavior = Behavior.new
		say("Add the action to the behavior...")
		behavior.actions << action
		say("Add a condition that they must collide first...")
		behavior.conditions << CollisionCondition.new
		say("Add the behavior to the creature...")
		predator.behaviors << behavior
		
		say("Drop the creature into the actual environment...")
		@environment.objects << predator
		
		say("And - chomp!")
		
	end


	#End the demos.
	def finish
		say "To learn more about how the library works, you can read the source code in the 'bin/zyps_demo' file in the Zyps distribution."
		say "And if you want to code your own Actions, Conditions, EnvironmentalFactors, or Views, see the distribution's 'lib' folder for examples."
		say "Thanks for watching!"
	end
	
	
	private
	
		#Explain what's going on to the user.
		def say(phrase)
			puts phrase
		end

	
end


begin
	#Run the demos.
	Demo.new.main_loop
rescue SystemExit
	#No action.
rescue Exception => exception
	#Print error to STDERR and exit with an abnormal status.
	abort "Error: " + exception.message
end
